using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.IO;
using Prism.Utils;

#if UNITY_EDITOR
[CustomEditor(typeof(PrismEffects))]
[CanEditMultipleObjects]
public class PrismEffectsEditor : Editor {
	
	SerializedObject serObj;
	
	string currentEffectsString = "";
	
	private Texture2D tempClutTex2D;
	private Texture2D tempSecondClutTex2D;
	
	bool showToneParams = false;

	static bool needsToSave = false;
	string extraSaveString = "";
	string extraLoadString = "";
	PrismPreset preset;

	static bool showBloom = true;
	static bool showChromatic = true;
	static bool showVignette = true;
	static bool showNoise = true;
	static bool showDof = true;
	static bool showTonemap = true;
	static bool showFog = true;
	static bool showRays = true;
	static bool showExposure = true;
	static bool showLut = true;
	static bool showNV = true;
	static bool showAO = true;
	
	GUIContent bloomContent = new GUIContent("Use Bloom", "Simulates the light fringing & bleeding artifacts of a camera lens");
	GUIContent bloomTypeContent = new GUIContent("   >Bloom Type", "The method used to create the bloom texture. HDR bloom is recommended for any HDR scene, simple bloom is marginally cheaper and works better with LDR/stylised scenes.");
	GUIContent bloomTextureSizeContent = new GUIContent("   >Bloom Downsample", "Increasing this value offers more performance, and a larger bloom area, at the cost of temporal stability");
	GUIContent bloomBlurPassesContent = new GUIContent("   >Bloom Blur Passes", "# of blur passes to apply to the bloom texture. More blur passes are more expensive, particularly if you are using a large base bloom texture");
	GUIContent bloomIntensityContent = new GUIContent("   >Bloom Intensity", "Increases the intensity of the bloom effect");
	GUIContent bloomExposureContent = new GUIContent("   >Bloom Exposure", "Adjusts the amount of exposure applied to the bloom texture");
	GUIContent bloomThresholdContent = new GUIContent("   >Bloom Threshold", "(OPTIONAL) - The bloom threshold may be desirable in scenes where you only want the brightest pixels to contribute to bloom");
	GUIContent bloomStabilityContent = new GUIContent("   >Use Stablility Buffer", "Uses the previous frames bloom texture to reduce 'firefly' artifacts");
	GUIContent bloomLensDirtContent = new GUIContent("   >Use Lens Dirt", "Applies the lens dirt texture to brighter areas of the image");
	GUIContent bloomLensDirtTextureContent = new GUIContent("     >Lens Dirt Texture", "Requires alpha channel");
	GUIContent bloomLensDirtIntensityContent = new GUIContent("     >Lens Dirt Intensity", "Increases the intensity of the lens dirt texture");
	GUIContent bloomDebugTextureContent = new GUIContent("   >Show Bloom Texture", "Shows you the bloom texture that is generated by the bloom pre-pass. Useful for debugging");
	GUIContent bloomBlurScreenContent = new GUIContent("     >Blur screen with bloom tex", "(Does not work with DoF) - Blurs the screen using the generated bloom texture, which has already undergone blur passes");
	GUIContent bloomUseScreenAddContent = new GUIContent("   >Use Screen Blend", "A smoother way of blending the bloom texture to the main texture, which also retains more detail. Only available in LDR.");

	GUIContent bloomUseUIBlurContent = new GUIContent("   >Use Bloom tex for UI blur", "Stores the blurred full-screen texture generated by the bloom effect for use with the PRISM/UI Blur shader. That shader will fallback to a lower performance GrabPass method if this is not checked.");
	GUIContent bloomUIBlurPassNumberContent = new GUIContent("     >Blur pass to grab from", "The bloom blur pass number that we will grab the full-screen blur texture from, the earlier the pass, the less blur. No performance impact.");

	GUIContent chromaticContent = new GUIContent("Use Chromatic Aberration", "Simulates 'color fringing' optical lens effect");
	GUIContent chromaticIntensityContent = new GUIContent("   >Chromatic Intensity", "Increases the intensity of the chromatic abberation effect");
	GUIContent chromaticTypeContent = new GUIContent("   >Aberration Type", "Vignette aberration applies to the corners of the image, vertical aberration applies to the vertical edges");
	
	GUIContent chromaticBlurContent = new GUIContent("   >Blur Edges", "Applies a blur to the areas of the screen affected by chromatic aberration. Requires 2 additional blur passes.");
	GUIContent chromaticBlurWidthContent = new GUIContent("     >Edge Blur Amount", "The width of the blur applied. Does not affect performance.");

	GUIContent dofContent = new GUIContent("Use Depth of Field", "Simulates camera lens defocus & bokeh artifacts");
	GUIContent dofRadiusContent = new GUIContent("   >DoF Radius", "Increases maximum blur radius and bokeh size. No impact on performance");
	GUIContent dofSampleContent = new GUIContent("   >DoF Sample Count", "Increases size of blur & bokeh, large impact on performance. Low is suitable in most cases");
	GUIContent dofBokehFactorContent = new GUIContent("   >DoF Bokeh Factor", "Increases propensity to generate Bokeh");
	GUIContent dofPointContent = new GUIContent("   >DoF Focus Point", "Distance at which to focus the camera");
	GUIContent dofDistanceContent = new GUIContent("   >DoF Focus Range", "DoF blur plane distance until it reaches maximum blur");
	GUIContent dofNearblurContent = new GUIContent("   >Use Near Blur", "When ticked, the Depth of Field will also blur pixels near the camera and outside of focal range");
	GUIContent dofNearDistanceContent = new GUIContent("     >DoF Near Focus Range", "DoF close blur plane distance until it reaches maximum blur");
	GUIContent dofBlurSkyboxContent = new GUIContent("   >Blur Skybox", "If enabled, the DoF effect will blur the skybox");
	GUIContent dofStabContent = new GUIContent("   >Use DoF Stablility Buffer", "If enabled, passes the screen through a median filter to generate a more stable texture for Bokeh (if ticked, this texture is also used for more stable Godrays and Bloom)");
	GUIContent dofDebugContent = new GUIContent("   >Visualise Focus", "Shows you the focus of the camera, where white is fully focused, and black is fully blurred. Useful for debugging");

	GUIContent vignetteContent = new GUIContent("Use Vignette", "Darkens the corners of the image");
	//GUIContent advVignetteContent = new GUIContent("   >Show Advanced Values", "Exposes the vignette start and end variables of the vignette, for a more controlled effect");
	
	GUIContent noiseContent = new GUIContent("Use Filmic Noise", "Adds semi-procedural filmic noise across the image");
	GUIContent noiseIntensityContent = new GUIContent("   >Noise Intensity", "Increases the intensity of the noise effect");
	
	GUIContent tonemapContent = new GUIContent("Use Tonemap", "Transforms color from Linear into Gamma color space");
	GUIContent tonemapTypeContent = new GUIContent("   >Tonemap Type", "Filmic = standard filmic tonemap, highly tweakable. RomB = similar, but with very nice deep colors");
	GUIContent tonemapParamsContent = new GUIContent("   >Tonemap Parameters", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");
	GUIContent tonemapSecondaryParamsContent = new GUIContent("   >Secondary Tonemap Params", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");
//	GUIContent tonemapShowParamsContent = new GUIContent("   >Show Raw Values", "Depending on what type of tonemapping you are using, these change different points in the tonemapping algorithm. In most cases, you shouldn't need to change them");

	GUIContent gammaCorrectionContent = new GUIContent("Use Gamma Correction", "Applies gamma correction to the final color of the image. Some monitors have slightly different base gamma values, so the gamma value should normally be user-set");
	GUIContent gammaValueContent = new GUIContent("   >Gamma Value", "Some monitors have slightly different base gamma values, so the gamma value should normally be user-set");

	GUIContent exposureAdaptContent = new GUIContent("Use Exposure Adaptation", "Simulates the ambient light response as human eyes adjust when going from a bright environment into a dark environment or vice versa");
	GUIContent exposureSpeedContent = new GUIContent("   >Exposure Speed", "The normalized delta-speed at which the 'eye' texture adapts towards the new value");
	//GUIContent exposureMultContent = new GUIContent("   >Exposure Multiplier", "Increases the intensity of the effect");
	GUIContent exposureOffsetContent = new GUIContent("   >Exposure Offset", "Changes the 'default' exposure value of the 'eye' by applying an offset");
	GUIContent exposureMinContent = new GUIContent("   >Minimum Exposure", "The minimum value that exposure will be clamped to (not an actual camera exposure value)");
	GUIContent exposureMatContent = new GUIContent("   >Maximum Exposure", "The maximum value that exposure will be clamped to (not an actual camera exposure value)");
	GUIContent exposureDebugContent = new GUIContent("   >View adaptation texture", "Render the exposure texture to half the screen, to visualise how fast it changes");
	
	GUIContent lutContent = new GUIContent("Use Color Correction LUT", "Replaces the standard colour palette with a new palette based on a lookup texture");
	GUIContent lutInfoContent = new GUIContent("   >Lookup Texture", "Texture to base the 3D Lookup texture on");
	GUIContent lutSecondaryInfoContent = new GUIContent("   >Use Secondary LUT", "Allows a secondary LUT texture to be used");
	
	GUIContent nightvisionContent = new GUIContent("Use Nightvision", "Simulates a Night-Vision lens by amplifying ambient light and converting it into a green spectrum");
	GUIContent nvColorContent = new GUIContent("   >Target Color", "Color of the main nightvision effect");
	GUIContent nvWhiteContent = new GUIContent("   >Target Bleach Color", "Color which brighter areas will be shown as");
	GUIContent nvLightingContribContent = new GUIContent("   >Lighting Contribution", "How much base lighting does the nightvision effect pick up");
	GUIContent nvLightSensContent = new GUIContent("   >Light Sensitivity", "The higher this value, the more bright areas will get 'bleached out'");

	GUIContent fogContent = new GUIContent("Use Fog", "Simulates a fog effect, which increases in intensity over distance, occluding distant objects");
	//GUIContent fogIntensityContent = new GUIContent("   >Fog Intensity", "Maximum thickness of the fog effect");
	GUIContent fogColorContent = new GUIContent("   >Fog Upper Color", "Upper (higher world-space) Color of the fog");
	GUIContent fogColorOneContent = new GUIContent("   >Fog Lower Color", "Lower (lower world-space) Color of the fog ");
	GUIContent fogStartPointContent = new GUIContent("   >Fog Start Point", "Distance away from the camera at which fog starts to occur");
	GUIContent fogDistanceContent = new GUIContent("   >Fog End", "Range in units that the fog takes to reach maximum intensity");
	GUIContent fogAffectSkyboxContent = new GUIContent("   >Apply to Skybox", "Applies the fog regardless of depth");
	//GUIContent fogHeightContent = new GUIContent("   >Fog Height", "The maximum height (in world units) of the fog");
	//GUIContent fogVerticalDistanceContent = new GUIContent("   >Fog Vertical Range", "Vertical range in units that the fog takes to reach maximum intensity");
	//GUIContent fogCongrastContent = new GUIContent("   >Fog Contrast Amount", "The maximum contrast multiplier that can be applied to the fog as it lerps from its primary to secondary color");

	GUIContent aoContent = new GUIContent("Use Ambient Obscurance", "Applies a screen-space ambient obscurance effect which approximates basic global illumination");
	GUIContent aoIntensityContent = new GUIContent("   >AO Intensity", "Darkness of the AO effect");
	GUIContent aoBlurPassesContent = new GUIContent("   >AO Blur Passes", "Number of bilateral blur passes performed on the AO texture. Moderate performance impact.");
	//GUIContent aoBlurFilterDistanceContent = new GUIContent("   >AO Blur Filter Distance", "Scales the distance of the AO blur effect, resulting in a larger/smaller blur");
	GUIContent aoDownsampleContent = new GUIContent("   >Use AO Downsample", "Perform all AO calculations at half resolution, saving performance.");
	GUIContent aoRadiusContent = new GUIContent("   >AO Radius", "The radius that the AO effect samples around geometry for occlusion");
	public GUIContent aoBiasContent = new GUIContent("     >AO Bias", "Increases the distance required between geometry to cause AO. Useful for fixing artifacts.");
	public GUIContent aoLightingContent = new GUIContent("     >AO Lighting Contribution", "Weights the AO based on the base lightness of the pixel, so that brighter pixels (like those lit by direct light) don't get AO applied");
	public GUIContent aoDebugContent = new GUIContent("   >View AO Texture", "Debug view of the AO-only texture");

	public GUIContent aoUseCutoffContent = new GUIContent("     >Use AO Cutoff", "Fade the AO effect out over distance");
	public GUIContent aoAdvancedContent = new GUIContent("   >Show Advanced Values", "Show advanced variables of the AO effect");
	public GUIContent aoCutoffStartContent = new GUIContent("       >AO Cutoff Start", "Start fading the AO out at this distance from the camera (Units)");
	public GUIContent aoCutoffRangeContent = new GUIContent("       >AO Cutoff Range", "Fade the AO effect out over this range (Units)");

	public GUIContent aoBlurTypeContent = new GUIContent("     >AO Blur type", "Changes the type of Bilateral blur the AO uses. Fast = ~15% faster per pass than Wide, but Wide performs a 'blurrier' blur");
	public GUIContent aoSampleQualityContent = new GUIContent("   >AO Sample Amount", "Takes more samples per pixel as increases. Can have a large impact on performance, particularly when not downsampling");

	GUIContent raysContent = new GUIContent("Use Godrays", "Simulates fake light scattering (Crepuscular Rays) when looking at a ray caster");
	GUIContent raysWeightContent = new GUIContent("   >Rays Weight", "Weight of the Rays effect. Around 0.5-0.6 is usually a good value");
	GUIContent raysColorContent = new GUIContent("   >Rays Color", "Main Color of the rays cast");
	GUIContent raysThresholdContent = new GUIContent("   >Rays Threshold", "Colors darker than this will be excluded from the blurring pass of the rays effect");
	GUIContent raysCasterContent = new GUIContent("   >Ray Caster", "The transform that the rays should come from (Usuall a directional light)");
	GUIContent raysDebugContent = new GUIContent("   >Show Rays Texture", "Renders a debug view of the rays texture");

	static bool hasDisplayedTonemapWarning = false;
	static bool hasDisplacedHDRWarning = false;
	static bool hasDisplayedGBufferWarning = false;
	
	void OnEnable() {
		
		serObj = new SerializedObject(target);
	}
	
	public override void OnInspectorGUI()
	{
		serObj.Update();
		
		PrismEffects prism = target as PrismEffects;

		GUIContent PrismPresetContent;
		if(prism.currentPrismPreset)
		{
			PrismPresetContent = new GUIContent("PRISM Preset:", "Preset description: " + prism.currentPrismPreset.PresetDescription);
		} else {
			PrismPresetContent = new GUIContent("PRISM Preset:", "");
		}		 

		//Preset
		EditorGUI.BeginChangeCheck();
		preset = (PrismPreset)EditorGUILayout.ObjectField(PrismPresetContent, prism.currentPrismPreset, typeof(PrismPreset), false);
		if(EditorGUI.EndChangeCheck())
		{
			Undo.RecordObject(target, "Change prism preset");
			extraLoadString = "";
			if(preset.presetType == PrismPresetType.Full)
			{
				prism.currentPrismPreset = preset;
			}
			LoadValuesFromPreset(prism, preset);
			return;
		}

		EditorGUILayout.BeginHorizontal();

		if(prism.currentPrismPreset)
		{
			if(needsToSave) 
			{
				extraSaveString = "";
			} else extraSaveString = "";

			if(GUILayout.Button("Save to preset" + extraSaveString))
			{
				SaveValuesToPreset(prism, prism.currentPrismPreset);
				return;
			} else if(GUILayout.Button(extraLoadString + "Reset to preset") )
			{
				extraLoadString = "";
				prism.currentPrismPreset = preset;
				LoadValuesFromPreset(prism, prism.currentPrismPreset);
				return;
			} else if(GUILayout.Button("Save as new preset"))
			{
				CreatePrismPresetAsset();
				prism.currentPrismPreset = (PrismPreset)Selection.activeObject as PrismPreset;
				SaveValuesToPreset(prism, prism.currentPrismPreset);
				Selection.activeObject = prism;
			} else if(GUILayout.Button("Clear preset"))
			{
				prism.currentPrismPreset = null;
				prism.SetPrismPreset(null);
				Selection.activeObject = prism;
			}
		} else {
			if(GUILayout.Button("Create PRISM Preset"))
			{
				CreatePrismPresetAsset();
				prism.currentPrismPreset = (PrismPreset)Selection.activeObject as PrismPreset;
				Selection.activeObject = prism;
			}
		}


		EditorGUILayout.EndHorizontal();

		EditorGUILayout.Space();
		
		//Start the horizontal (2 per line) GUI layour
		EditorGUILayout.BeginVertical();
		
		ResetCurrentEffectsString(prism);
		
		EditorGUILayout.LabelField("Current effects: ");
		
		EditorGUILayout.LabelField(new GUIContent(currentEffectsString, currentEffectsString));
		EditorGUILayout.EndVertical();

		
		EditorGUILayout.Space();
		
		//Bloom
		EditorGUILayout.BeginHorizontal();
		
		prism.useBloom = EditorGUILayout.Toggle(bloomContent, prism.useBloom);
		EditorGUILayout.EndHorizontal();

		if(prism.useBloom)
			showBloom = EditorGUILayout.Foldout(showBloom, " >Show Bloom Values");

		if(prism.useBloom && showBloom)
		{			
			EditorGUI.BeginChangeCheck();
			BloomType blmType = (BloomType)EditorGUILayout.EnumPopup(bloomTypeContent, prism.bloomType);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Blm type");
				prism.bloomType = blmType;

				if(blmType == BloomType.HDR)
				{
					prism.bloomIntensity = Mathf.Min(prism.bloomIntensity, 0.065f);
				}
			}

			if(prism.bloomType != BloomType.HDR)
			{
				EditorGUI.BeginChangeCheck();
				int blmDownsample = EditorGUILayout.IntSlider(bloomTextureSizeContent, prism.bloomDownsample, 1, 4);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Downsample Bloom");
					prism.bloomDownsample = blmDownsample;
				}
				
				EditorGUI.BeginChangeCheck();
				int blmBlurPasses = EditorGUILayout.IntSlider(bloomBlurPassesContent, prism.bloomBlurPasses, 1, 8);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blur Bloom");
					prism.bloomBlurPasses = blmBlurPasses;
				}			
				
				EditorGUI.BeginChangeCheck();
				float blmIntensity = EditorGUILayout.Slider(bloomIntensityContent, prism.bloomIntensity, 0f, 1f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Intense");
					prism.bloomIntensity = blmIntensity;
				}
				
				EditorGUI.BeginChangeCheck();
				float blmThresh = EditorGUILayout.Slider(bloomThresholdContent, prism.bloomThreshold, 0f, 1.0f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Thresh");
					prism.bloomThreshold = blmThresh;
				}			
				
				EditorGUI.BeginChangeCheck();
				bool blmStab = EditorGUILayout.Toggle(bloomStabilityContent, prism.useBloomStability);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Stab");
					prism.useBloomStability = blmStab;
				}
				
				if(prism.GetPrismCamera().hdr == false)
				{
					EditorGUI.BeginChangeCheck();
					bool blmBlendMode = EditorGUILayout.Toggle(bloomUseScreenAddContent, prism.bloomUseScreenBlend);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "Blm blend");
						prism.bloomUseScreenBlend = blmBlendMode;
					}
				}
			} else {

				if(prism.GetPrismCamera().hdr == false)
				{
					EditorGUILayout.HelpBox ("You are using HDR bloom on a camera that is not set to HDR, or you have an LDR image effect before PRISM.", MessageType.Warning);
				}

				EditorGUI.BeginChangeCheck();
				float blmIntensity = EditorGUILayout.Slider(bloomIntensityContent, prism.bloomIntensity, 0f, 0.35f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Intense");
					prism.bloomIntensity = blmIntensity;
				}
				
				EditorGUI.BeginChangeCheck();
				float blmExposure = EditorGUILayout.Slider(bloomExposureContent, prism.bloomThreshold, 0f, 2f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm x");
					prism.bloomThreshold = blmExposure;
				}

				EditorGUI.BeginChangeCheck();
				bool blmStab = EditorGUILayout.Toggle(bloomStabilityContent, prism.useBloomStability);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Stab");
					prism.useBloomStability = blmStab;
				}
			}
			
			EditorGUI.BeginChangeCheck();
			bool blmDirt = EditorGUILayout.Toggle(bloomLensDirtContent, prism.useLensDirt);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Blm Dirt");
				prism.useLensDirt = blmDirt;
			}
			
			if(blmDirt)
			{
				float maxDirtIntens = 5f;

				if(prism.bloomType == BloomType.HDR) maxDirtIntens = 1.5f;

				EditorGUI.BeginChangeCheck();
				prism.lensDirtTexture = (Texture2D)EditorGUILayout.ObjectField(bloomLensDirtTextureContent, prism.lensDirtTexture, typeof(Texture2D), false);
				
				EditorGUI.BeginChangeCheck();
				float drtInten = EditorGUILayout.Slider(bloomLensDirtIntensityContent, prism.dirtIntensity, 0f, maxDirtIntens);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm Dirt intens");
					prism.dirtIntensity = drtInten;
				}
			}

			EditorGUI.BeginChangeCheck();
			bool uiblur = EditorGUILayout.Toggle(bloomUseUIBlurContent, prism.useUIBlur);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Blm uiblur");
				prism.useUIBlur = uiblur;
				prism.Reset();
			}
			
			if(uiblur == true && prism.bloomType != BloomType.HDR)
			{
				EditorGUI.BeginChangeCheck();
				int uiblurPassNum = EditorGUILayout.IntSlider(bloomUIBlurPassNumberContent, prism.uiBlurGrabTextureFromPassNumber, 0, prism.bloomBlurPasses-1);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blur passnum");
					prism.uiBlurGrabTextureFromPassNumber = uiblurPassNum;
				}			
			}
			
			EditorGUI.BeginChangeCheck();
			bool debgBlmTex = EditorGUILayout.Toggle(bloomDebugTextureContent, prism.debugBloomTex);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Blm Dbg");
				prism.debugBloomTex = debgBlmTex;
			}

			if(prism.useDof == false)
			{
				EditorGUI.BeginChangeCheck();
				bool blrScrn = EditorGUILayout.Toggle(bloomBlurScreenContent, prism.useFullScreenBlur);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Blm blur");
					prism.useFullScreenBlur = blrScrn;
					if(blrScrn)
					{
						prism.dofForceEnableMedian = true;
					} else {
						prism.dofForceEnableMedian = false;
					}

				}

			}

		}
		
		GUILayout.Space(1f);
		
		//Fog
		EditorGUILayout.BeginHorizontal();
		
		prism.useFog = EditorGUILayout.Toggle(fogContent, prism.useFog);
		EditorGUILayout.EndHorizontal();

		if(prism.useFog)
			showFog = EditorGUILayout.Foldout(showFog, " >Show Fog Values");
		
		if(prism.useFog && showFog)
		{	
			/*EditorGUI.BeginChangeCheck();
			float fogInten = EditorGUILayout.Slider(fogIntensityContent, prism.fogIntensity, 0f, 1.0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog intens");
				prism.fogIntensity = fogInten;
			}*/

			EditorGUI.BeginChangeCheck();
			float fogStart = EditorGUILayout.FloatField(fogStartPointContent, prism.fogStartPoint);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog start");
				prism.fogStartPoint = fogStart;
			}

			EditorGUI.BeginChangeCheck();
			float fogDist = EditorGUILayout.Slider(fogDistanceContent, prism.fogDistance, Mathf.Max(0.1f, 0.1f + prism.fogStartPoint), 500f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog d");
				prism.fogDistance = fogDist;
			}
			
			/*EditorGUI.BeginChangeCheck();
			float fogHeight = EditorGUILayout.FloatField(fogHeightContent, prism.fogHeight);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog ghet");
				prism.fogHeight = fogHeight;
			}

			EditorGUI.BeginChangeCheck();
			float fogHeightDist = EditorGUILayout.Slider(fogVerticalDistanceContent, prism.fogVerticalDistance, 0.1f, 200f);
			//float fogHeightDist = EditorGUILayout.FloatField(fogVerticalDistanceContent, prism.fogVerticalDistance);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog middist");
				prism.fogVerticalDistance = fogHeightDist;
			}*/

			EditorGUI.BeginChangeCheck();
			Color fogStartCol = EditorGUILayout.ColorField(fogColorContent, prism.fogColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog1 color");
				prism.fogColor = fogStartCol;
			}

			EditorGUI.BeginChangeCheck();
			Color fogEndCol = EditorGUILayout.ColorField(fogColorOneContent, prism.fogEndColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Fog2 color");
				prism.fogEndColor = fogEndCol;
			}

			
			EditorGUI.BeginChangeCheck();
			bool fogSkybox = EditorGUILayout.Toggle(fogAffectSkyboxContent, prism.fogAffectSkybox);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "fog blur skybox");
				prism.fogAffectSkybox = fogSkybox;
			}


		}
		
		GUILayout.Space(1f);
		
		//Dof
		EditorGUILayout.BeginHorizontal();
		
		prism.useDof = EditorGUILayout.Toggle(dofContent, prism.useDof);
		EditorGUILayout.EndHorizontal();

		if(prism.useDof)
			showDof = EditorGUILayout.Foldout(showDof, " >Show DoF Values");
		
		if(prism.useDof && showDof)
		{
			EditorGUI.BeginChangeCheck();
			float dofRadius = EditorGUILayout.Slider(dofRadiusContent, prism.dofRadius, 0f, 2.0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof rad");
				prism.dofRadius = dofRadius;
			}
			
			EditorGUI.BeginChangeCheck();
			DoFSamples dofSamples = (DoFSamples)EditorGUILayout.EnumPopup(dofSampleContent, prism.dofSampleAmount);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof SampleQual");
				prism.dofSampleAmount = dofSamples;
			}
			
			EditorGUI.BeginChangeCheck();
			float dofFactor = EditorGUILayout.Slider(dofBokehFactorContent, prism.dofBokehFactor, 0f, 300.0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof factor");
				prism.dofBokehFactor = dofFactor;
			}
			
			EditorGUI.BeginChangeCheck();
			float dofPoint = EditorGUILayout.FloatField(dofPointContent, prism.dofFocusPoint);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof point");
				prism.dofFocusPoint = dofPoint;
			}
			
			EditorGUI.BeginChangeCheck();
			float dofDist = EditorGUILayout.Slider(dofDistanceContent, prism.dofFocusDistance, 0f, 100.0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof point");
				prism.dofFocusDistance = dofDist;
			}

			EditorGUI.BeginChangeCheck();
			bool dofBlurSkybox = EditorGUILayout.Toggle(dofBlurSkyboxContent, prism.dofBlurSkybox);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof blur skybox");
				prism.dofBlurSkybox = dofBlurSkybox;
			}

			EditorGUI.BeginChangeCheck();
			bool dofNearBlur = EditorGUILayout.Toggle(dofNearblurContent, prism.useNearDofBlur);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof blur");
				prism.useNearDofBlur = dofNearBlur;
			}

			EditorGUI.BeginChangeCheck();
			bool dofStab = EditorGUILayout.Toggle(dofStabContent, prism.dofForceEnableMedian);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof stab");
				prism.dofForceEnableMedian = dofStab;
			}
			
			if(prism.useNearDofBlur)
			{
				EditorGUI.BeginChangeCheck();
				float dofNearDist = EditorGUILayout.Slider(dofNearDistanceContent, prism.dofNearFocusDistance, 0f, 100.0f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Dof dist near");
					prism.dofNearFocusDistance = dofNearDist;
				}
			}


			EditorGUI.BeginChangeCheck();
			bool dofDebug = EditorGUILayout.Toggle(dofDebugContent, prism.debugDofPass);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Dof debg");
				prism.debugDofPass = dofDebug;
			}
			
		}
		
		
		GUILayout.Space(1f);

		//Dof
		EditorGUILayout.BeginHorizontal();
		
		prism.useAmbientObscurance = EditorGUILayout.Toggle(aoContent, prism.useAmbientObscurance);
		EditorGUILayout.EndHorizontal();

		if(prism.useAmbientObscurance)
			showAO = EditorGUILayout.Foldout(showAO, " >Show AO Values");

		if(prism.useAmbientObscurance && showAO)
		{
			
			EditorGUI.BeginChangeCheck();
			float aoIntens = EditorGUILayout.Slider(aoIntensityContent, prism.aoIntensity, 0f, 2.5f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "AO int");
				prism.aoIntensity = aoIntens;
			}
			
			EditorGUI.BeginChangeCheck();
			float aoRad = EditorGUILayout.Slider(aoRadiusContent, prism.aoRadius, 0f, 2.0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "AO Rad");
				prism.aoRadius = aoRad;
			}
			
			EditorGUI.BeginChangeCheck();
			SampleCount aoSamples = (SampleCount)EditorGUILayout.EnumPopup(aoSampleQualityContent, prism.aoSampleCount);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "ao SampleQual");
				prism.aoSampleCount = aoSamples;
			}
			
			EditorGUI.BeginChangeCheck();
			int aoBlurNum = EditorGUILayout.IntSlider(aoBlurPassesContent, prism.aoBlurIterations, 0, 3);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "AO Blur#");
				prism.aoBlurIterations = aoBlurNum;
			}
			
			EditorGUI.BeginChangeCheck();
			bool aoDown = EditorGUILayout.Toggle(aoDownsampleContent, prism.aoDownsample);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "AO downs");
				prism.aoDownsample = aoDown;
			}

			EditorGUI.BeginChangeCheck();
			bool aoAdvanced = EditorGUILayout.Toggle(aoAdvancedContent, prism.advancedAO);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "AO adv");
				prism.advancedAO = aoAdvanced;
			}

			if(prism.advancedAO)
			{
				if(!prism.IsGBufferAvailable)
				{
					if(!hasDisplayedGBufferWarning)
					{
						//Debug.Log("You are not currently using deferred rendering. PRISM.AO works best in deferred, and will switch to a slightly lower quality AO in forward rendering");
						hasDisplayedGBufferWarning = true;
					}
				}

				EditorGUI.BeginChangeCheck();
				float aolghtbs = EditorGUILayout.Slider(aoLightingContent, prism.aoLightingContribution, 0f, 1.0f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "AO lgt");
					prism.aoLightingContribution = aolghtbs;
				}
				
				EditorGUI.BeginChangeCheck();
				float aobs = EditorGUILayout.Slider(aoBiasContent, prism.aoBias, 0f, 1.0f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "AO bs");
					prism.aoBias = aobs;
				}

				//if(prism.IsGBufferAvailable)
				//{
					EditorGUI.BeginChangeCheck();
					AOBlurType aoblurtype = (AOBlurType)EditorGUILayout.EnumPopup(aoBlurTypeContent, prism.aoBlurType);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "ao blurtype");
						prism.aoBlurType = aoblurtype;
					}
				//} else {
				//	prism.aoBlurType = AOBlurType.Fast;
				//}

				EditorGUI.BeginChangeCheck();
				bool aoCut = EditorGUILayout.Toggle(aoUseCutoffContent, prism.useAODistanceCutoff);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "AO downs");
					prism.useAODistanceCutoff = aoCut;
				}
				
				if(prism.useAODistanceCutoff)
				{
					if(prism.useDof)
					{
						EditorGUILayout.HelpBox ("When Depth Of Field and AO is used, PRISM will automatically apply an AO cutoff as the DoF fades in, to prevent harsh lines.", MessageType.Info);
					}

					//Cutoff stuff
					EditorGUI.BeginChangeCheck();
					float aoStartD = EditorGUILayout.Slider(aoCutoffStartContent, prism.aoDistanceCutoffStart, 0f, 1000.0f);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "AO Cutoff start");
						prism.aoDistanceCutoffStart = aoStartD;
					}
					
					EditorGUI.BeginChangeCheck();
					float aoRangeD = EditorGUILayout.Slider(aoCutoffRangeContent, prism.aoDistanceCutoffLength, 0f, 150f);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "ao Cutoff range");
						prism.aoDistanceCutoffLength = aoRangeD;
					}
					//End
				}
			}
	
			
			EditorGUI.BeginChangeCheck();
			bool aoDebug = EditorGUILayout.Toggle(aoDebugContent, prism.aoShowDebug);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "a debg");
				prism.aoShowDebug = aoDebug;
			}
			
		}

		
		
		GUILayout.Space(1f);
		
		//Chromatic
		EditorGUILayout.BeginHorizontal();
		
		prism.useChromaticAberration = EditorGUILayout.Toggle(chromaticContent, prism.useChromaticAberration);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useChromaticAberration)
			showChromatic = EditorGUILayout.Foldout(showChromatic, " >Show Chromatic Values");

		if(prism.useChromaticAberration && showChromatic)
		{
			EditorGUI.BeginChangeCheck();
			AberrationType chromAbType = (AberrationType)EditorGUILayout.EnumPopup(chromaticTypeContent, prism.aberrationType);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Aber type");
				prism.aberrationType = chromAbType;
			}
			
			EditorGUI.BeginChangeCheck();
			float chromInten = EditorGUILayout.Slider(chromaticIntensityContent, prism.chromaticIntensity, 0f, 0.15f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Chrom intens");
				if(prism.aberrationType == AberrationType.Vertical)
				{
					prism.chromaticIntensity = chromInten;
				} else {
					prism.chromaticIntensity = chromInten;
				}
			}
			
			EditorGUI.BeginChangeCheck();
			float chromOne = EditorGUILayout.Slider("   >Chromatic Start", prism.chromaticDistanceOne, 0f, 1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Chrom 1");
				prism.chromaticDistanceOne = chromOne;
			}
			
			EditorGUI.BeginChangeCheck();
			float chromTwo = EditorGUILayout.Slider("   >Chromatic End", prism.chromaticDistanceTwo, 0f, 1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Chrom 2");
				prism.chromaticDistanceTwo = chromTwo;
			}

			EditorGUI.BeginChangeCheck();
			bool chromBlur = EditorGUILayout.Toggle(chromaticBlurContent, prism.useChromaticBlur);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Chrom b");
				prism.useChromaticBlur = chromBlur;
			}

			if(prism.useChromaticBlur)
			{
				EditorGUI.BeginChangeCheck();
				float chromBlurWidth = EditorGUILayout.Slider(chromaticBlurWidthContent, prism.chromaticBlurWidth, 0f, 1f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Chrom blur width");
					prism.chromaticBlurWidth = chromBlurWidth;
				}
			}
			
		}
		
		
		GUILayout.Space(1f);
		
		//Vignette
		EditorGUILayout.BeginHorizontal();
		
		prism.useVignette = EditorGUILayout.Toggle(vignetteContent, prism.useVignette);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useVignette)
			showVignette = EditorGUILayout.Foldout(showVignette, " >Show Vignette Values");
		
		if(prism.useVignette && showVignette)
		{
			EditorGUI.BeginChangeCheck();
			float vigI = EditorGUILayout.Slider("   >Vignette Intensity", prism.vignetteStrength, 0f, 1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Vig 3");
				prism.vignetteStrength = vigI ;
			}

			EditorGUI.BeginChangeCheck();
			Color vigCol = EditorGUILayout.ColorField("   >Vignette Color", prism.vignetteColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Vig color");
				prism.vignetteColor = vigCol;
			}

			/*EditorGUI.BeginChangeCheck();
			bool advVignette = EditorGUILayout.Toggle(advVignetteContent, prism.advancedVignette);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Advanced vignette");
				prism.advancedVignette = advVignette;
			}*/
			
			//if(prism.advancedVignette)
			//{
				EditorGUI.BeginChangeCheck();
				float vigOne = EditorGUILayout.Slider("   >Vignette Start", prism.vignetteEnd, 0f, 1f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Vig 1");
					prism.vignetteEnd = vigOne;
				}
				
				EditorGUI.BeginChangeCheck();
				float vigTwo = EditorGUILayout.Slider("   >Vignette End", prism.vignetteStart, 0f, 1f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Vig 2");
					prism.vignetteStart = vigTwo ;
				}
			//}
		}

		
		
		GUILayout.Space(1f);

		//Filmic Grain
		EditorGUILayout.BeginHorizontal();
		
		prism.useNoise = EditorGUILayout.Toggle(noiseContent, prism.useNoise);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useNoise)
			showNoise = EditorGUILayout.Foldout(showNoise, " >Show Noise Values");
		
		if(prism.useNoise && showNoise)
		{
			EditorGUI.BeginChangeCheck();
			float noiseIntens = EditorGUILayout.Slider(noiseIntensityContent, prism.noiseIntensity, 0f, 2f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Noise intens");
				prism.noiseIntensity = noiseIntens;
			}
		}

		
		
		GUILayout.Space(1f);

		//Tonemap
		EditorGUILayout.BeginHorizontal();
		
		prism.useTonemap = EditorGUILayout.Toggle(tonemapContent, prism.useTonemap);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useTonemap)
			showTonemap = EditorGUILayout.Foldout(showTonemap, " >Show Tonemap Values");
		
		if(prism.useTonemap && showTonemap)
		{
			if(QualitySettings.activeColorSpace == ColorSpace.Gamma)
			{
				if(!PrismEffectsEditor.hasDisplayedTonemapWarning)
				{
					Debug.LogWarning("Warning - you are trying to use a tonemap while using Gamma color space. It is advised to change this to Linear in your player settings.");
					PrismEffectsEditor.hasDisplayedTonemapWarning = true;
				}
			}

			if(prism.GetPrismCamera().hdr == false)
			{
				if(!PrismEffectsEditor.hasDisplacedHDRWarning)
				{
					Debug.LogWarning("Warning - you are trying to use a tonemap on a non-HDR camera. Consider changing your camera to HDR.");
					PrismEffectsEditor.hasDisplacedHDRWarning = true;
				}
			}
			
			EditorGUI.BeginChangeCheck();
			TonemapType toneType = (TonemapType)EditorGUILayout.EnumPopup(tonemapTypeContent, prism.tonemapType);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Tonemap type");
				prism.tonemapType = toneType;
				if(toneType == TonemapType.Filmic)
				{
					prism.ResetToneParamsFilmic();
				} else if(toneType == TonemapType.RomB){
					prism.ResetToneParamsRomB();
				} else if(toneType == TonemapType.ACES) {
					prism.ResetToneParamsACES();
				}
			}
			
			showToneParams = true;//EditorGUILayout.Toggle(tonemapShowParamsContent, showToneParams);
			if(showToneParams)
			{
				//Tell user about values
				if(toneType == TonemapType.Filmic)
				{
					EditorGUILayout.HelpBox ("X value controls the white point of the filmic tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}

				if(toneType == TonemapType.RomB)
				{
					EditorGUILayout.HelpBox ("Y value controls the white point of the RomB tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}
				
				if(toneType == TonemapType.ACES)
				{
					EditorGUILayout.HelpBox ("X value controls the white point of the ACES tonemap. It is recommended to not alter other values, and use color correction to apply color modifications.", MessageType.Info);
				}

				EditorGUI.BeginChangeCheck();
				Vector3 toneStuff = EditorGUILayout.Vector3Field(tonemapParamsContent, prism.toneValues);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Tone Params");
					prism.toneValues = toneStuff;
				}

				if(toneType != TonemapType.RomB)
				{
					EditorGUI.BeginChangeCheck();
					Vector3 tone2Stuff = EditorGUILayout.Vector3Field(tonemapSecondaryParamsContent, prism.secondaryToneValues);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "Tone 2Params");
						prism.secondaryToneValues = tone2Stuff;
					}
				}
			}			
		}
		
		
		GUILayout.Space(1f);

		//Adapt
		EditorGUILayout.BeginHorizontal();
		
		prism.useExposure = EditorGUILayout.Toggle(exposureAdaptContent, prism.useExposure);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useExposure)
			showExposure = EditorGUILayout.Foldout(showExposure, " >Show Exposure Values");

		if(prism.useExposure && showExposure)
		{
			EditorGUI.BeginChangeCheck();
			float exSpeed = EditorGUILayout.Slider(exposureSpeedContent, prism.exposureSpeed, 0f, 20f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Exposure speed");
				prism.exposureSpeed = exSpeed;
			}

			EditorGUI.BeginChangeCheck();
			float exOffset = EditorGUILayout.Slider(exposureOffsetContent, prism.exposureMiddleGrey, 0f, 1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Exposure offset");
				prism.exposureMiddleGrey = exOffset;
			}

			EditorGUI.BeginChangeCheck();
			float exLower = EditorGUILayout.Slider(exposureMinContent, prism.exposureLowerLimit, -10f, 0f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Exposure lower");
				prism.exposureLowerLimit = exLower;
			}

			EditorGUI.BeginChangeCheck();
			float exUpper = EditorGUILayout.Slider(exposureMatContent, prism.exposureUpperLimit, 0f, 10f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Exposure upper");
				prism.exposureUpperLimit = exUpper;
			}

			EditorGUI.BeginChangeCheck();
			bool dbgExposure = EditorGUILayout.Toggle(exposureDebugContent, prism.debugViewExposure);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Use debug exposure");
				prism.debugViewExposure = dbgExposure;
			}
		}
		GUILayout.Space(1f);
		//Lut
		EditorGUILayout.BeginHorizontal();

		EditorGUI.BeginChangeCheck();
		bool useLt = EditorGUILayout.Toggle(lutContent, prism.useLut);
		if(EditorGUI.EndChangeCheck())
		{
			Undo.RecordObject(target, "Lut");
			prism.useLut = useLt;

			if(useLt == true)
			{
				prism.enabled = false;
				prism.enabled = true;
			}
		}
		
		EditorGUILayout.EndHorizontal();

		if(prism.useLut)
			showLut = EditorGUILayout.Foldout(showLut, " >Show LUT Values");
		
		if(prism.useLut && showLut)
		{
			Rect r; 
			Texture2D t;

			EditorGUI.BeginChangeCheck();

			tempClutTex2D = EditorGUILayout.ObjectField (lutInfoContent, tempClutTex2D, typeof(Texture2D), false) as Texture2D;
			if (tempClutTex2D == null) {
				t = prism.twoDLookupTex;
				if (t) tempClutTex2D = t;
			}
			
			Texture2D tex = tempClutTex2D;

			if(EditorGUI.EndChangeCheck())
			{
				Debug.LogWarning("Converting");
				prism.Convert(tex);
			}

			if(prism.twoDLookupTex)
			if (tex && prism.basedOnTempTex != prism.twoDLookupTex.name)
			{
				EditorGUILayout.Separator();
				if (!prism.ValidDimensions(tex))
				{
					EditorGUILayout.HelpBox ("Invalid texture dimensions!\nPick another texture or adjust dimension to e.g. 256x16.", MessageType.Warning);
				}
				else if(!prism.enabled)
				{

				}else if (GUILayout.Button ("Convert and Apply LUT!"))
				{
					string path = AssetDatabase.GetAssetPath (tex);
					TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
					bool doImport = textureImporter.isReadable == false;
					if (textureImporter.mipmapEnabled == true) {
						doImport = true;
					}
					if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
						doImport = true;
					}
					
					if (doImport)
					{
						textureImporter.isReadable = true;
						textureImporter.mipmapEnabled = false;
						textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
						AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
					}
					
					prism.Convert(tex);
				}
			}
			
			if (prism.threeDLookupTex != null && prism.twoDLookupTex != null)
			{
				EditorGUILayout.BeginHorizontal();
				GUILayout.Space(150f);
				if (GUILayout.Button ("Flip LUT (fixes Amplify Color LUTs)"))
				{
					prism.twoDLookupTex = FlipTexture(prism.twoDLookupTex);
					prism.Reset();
					OnEnable();
				}
				EditorGUILayout.EndHorizontal();

				EditorGUI.BeginChangeCheck();
				float lutI = EditorGUILayout.Slider("   >LUT Intensity", prism.lutLerpAmount, 0f, 1f);
				if(EditorGUI.EndChangeCheck())
				{
					Undo.RecordObject(target, "Lut intense");
					prism.lutLerpAmount = lutI ;
				}

				if(prism.basedOnTempTex == "")
				{
					string pth = prism.twoDLookupTex.name;
					prism.basedOnTempTex = pth;
				}

				EditorGUILayout.LabelField("   >Using: " + prism.basedOnTempTex);
				t = prism.twoDLookupTex;
				if (t) {
					r = GUILayoutUtility.GetLastRect();
					r = GUILayoutUtility.GetRect(r.width, 20);
					r.x += r.width * 0.05f/2.0f;
					r.width *= 0.95f;
					GUI.DrawTexture (r, t);
					GUILayoutUtility.GetRect(r.width, 4);
				}
			}

			EditorGUI.BeginChangeCheck();
			bool secc = EditorGUILayout.Toggle(lutSecondaryInfoContent, prism.useSecondLut);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Use 2sec");
				prism.useSecondLut = secc;
			}
			
			if(prism.useSecondLut)
			{
				Rect r2; 
				Texture2D t2;

				EditorGUI.BeginChangeCheck();
				
				tempSecondClutTex2D = EditorGUILayout.ObjectField (lutInfoContent, tempSecondClutTex2D, typeof(Texture2D), false) as Texture2D;
				if (tempSecondClutTex2D == null) {
					t2 = prism.secondaryTwoDLookupTex;
					if (t2) tempSecondClutTex2D = t2;
				}
				
				Texture2D tex2 = tempSecondClutTex2D;
				
				if(EditorGUI.EndChangeCheck())
				{
					Debug.LogWarning("Converting 2nd LUT");
					prism.Convert(tex2, true);
					prism.Reset();
				}
				
				if (tex2 && prism.secondaryTwoDLookupTex != null && prism.secondaryBasedOnTempTex != prism.secondaryTwoDLookupTex.name)
				{
					EditorGUILayout.Separator();
					if (!prism.ValidDimensions(tex2))
					{
						EditorGUILayout.HelpBox ("Invalid texture dimensions for LUT 2!\nPick another texture or adjust dimension to e.g. 256x16.", MessageType.Warning);
					} else if (prism.enabled == false)
					{

					} else if (GUILayout.Button ("Convert and Apply LUT 2!"))
					{
						string path = AssetDatabase.GetAssetPath (tex2);
						TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
						bool doImport = textureImporter.isReadable == false;
						if (textureImporter.mipmapEnabled == true) {
							doImport = true;
						}
						if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
							doImport = true;
						}
						
						if (doImport)
						{
							textureImporter.isReadable = true;
							textureImporter.mipmapEnabled = false;
							textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
							AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
						}
						
						prism.Convert(tex2, true);
					}
				}
				
				if (prism.secondaryThreeDLookupTex != null && prism.secondaryTwoDLookupTex != null)
				{
					EditorGUILayout.BeginHorizontal();
					GUILayout.Space(150f);
					if (GUILayout.Button ("Flip LUT (fixes Amplify Color LUTs)"))
					{
						prism.twoDLookupTex = FlipTexture(prism.secondaryTwoDLookupTex);
						prism.Reset();
						OnEnable();
					}
					EditorGUILayout.EndHorizontal();

					EditorGUI.BeginChangeCheck();
					float lutI2 = EditorGUILayout.Slider("   >Second LUT Intensity", prism.secondaryLutLerpAmount, 0f, 1f);
					if(EditorGUI.EndChangeCheck())
					{
						Undo.RecordObject(target, "Lut intense");
						prism.secondaryLutLerpAmount = lutI2;
					}
					
					if(prism.secondaryBasedOnTempTex == "")
					{
						string pth2 = prism.secondaryTwoDLookupTex.name;
						prism.secondaryBasedOnTempTex = pth2;
					}
					
					EditorGUILayout.LabelField("   >Using: " + prism.secondaryBasedOnTempTex);
					t2 = prism.secondaryTwoDLookupTex;
					if (t2) {
						r2 = GUILayoutUtility.GetLastRect();
						r2 = GUILayoutUtility.GetRect(r2.width, 20);
						r2.x += r2.width * 0.05f/2.0f;
						r2.width *= 0.95f;
						GUI.DrawTexture (r2, t2);
						GUILayoutUtility.GetRect(r2.width, 4);
					}
				}
			}
		}
		
		
		GUILayout.Space(1f);
		
		//Nightvision
		EditorGUILayout.BeginHorizontal();
		
		prism.useNightVision = EditorGUILayout.Toggle(nightvisionContent, prism.useNightVision);
		
		EditorGUILayout.EndHorizontal();

		if(prism.useNightVision)
			showNV = EditorGUILayout.Foldout(showNV, " >Show Nightvision Values");
		
		if(prism.useNightVision && showNV)
		{			
			/*EditorGUILayout.PropertyField(p_NVColor);
			EditorGUILayout.PropertyField(p_BleachColor);
			EditorGUILayout.PropertyField(p_BaseLightingContrib);
			EditorGUILayout.PropertyField(p_LightSensMult);*/
			
			EditorGUI.BeginChangeCheck();
			Color nvCol = EditorGUILayout.ColorField(nvColorContent, prism.m_NVColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "NV color");
				prism.m_NVColor = nvCol;
			}
			
			EditorGUI.BeginChangeCheck();
			Color nvBleach = EditorGUILayout.ColorField(nvWhiteContent, prism.m_TargetBleachColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "NV bleach color");
				prism.m_TargetBleachColor = nvBleach;
			}
			
			EditorGUI.BeginChangeCheck();
			float nvContrib = EditorGUILayout.Slider(nvLightingContribContent, prism.m_baseLightingContribution, 0f, 0.1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "NV contrib");
				prism.m_baseLightingContribution = nvContrib;
			}
			
			EditorGUI.BeginChangeCheck();
			float nvSens = EditorGUILayout.Slider(nvLightSensContent, prism.m_LightSensitivityMultiplier, 0f, 128f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "NV sens");
				prism.m_LightSensitivityMultiplier = nvSens;
			}
		}
		
		
		GUILayout.Space(1f);

		//Rays
		EditorGUILayout.BeginHorizontal();

		EditorGUI.BeginChangeCheck();
		prism.useRays = EditorGUILayout.Toggle(raysContent, prism.useRays);
		if(EditorGUI.EndChangeCheck())
		{
			if(!prism.rayTransform)
			{
				var sunsInScene = FindObjectsOfType(typeof(Light)) as Light[];
				foreach(var v in sunsInScene)
				{
					if(v.type == LightType.Directional)
					{
						prism.rayTransform = v.transform;
					}
				}
			}
		}
		
		EditorGUILayout.EndHorizontal();

		if(prism.useRays)
			showRays = EditorGUILayout.Foldout(showRays, " >Show Godrays Values");
		
		if(prism.useRays && showRays)
		{	
			EditorGUI.BeginChangeCheck();
			float rWgt = EditorGUILayout.Slider(raysWeightContent, prism.rayWeight, 0f, 1f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Ray weight");
				prism.rayWeight = rWgt;
			}

			EditorGUI.BeginChangeCheck();
			Color rayCol = EditorGUILayout.ColorField(raysColorContent, prism.rayColor);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Ray color");
				prism.rayColor = rayCol;
			}
			
			EditorGUI.BeginChangeCheck();
			Color rayThresh = EditorGUILayout.ColorField(raysThresholdContent, prism.rayThreshold);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Ray trhesh color");
				prism.rayThreshold = rayThresh;
			}

			EditorGUI.BeginChangeCheck();
			Transform raysT = (Transform)EditorGUILayout.ObjectField(raysCasterContent, prism.rayTransform, typeof(Transform), true);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Rays transform");
				prism.rayTransform = raysT;
			}

			EditorGUI.BeginChangeCheck();
			bool dbgRs = EditorGUILayout.Toggle(raysDebugContent, prism.raysShowDebug);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Use debug rays");
				prism.raysShowDebug = dbgRs;
			}
		}
		
		
		GUILayout.Space(1f);
		
		EditorGUI.BeginChangeCheck();
		bool useGamma = EditorGUILayout.Toggle(gammaCorrectionContent, prism.useGammaCorrection);
		if(EditorGUI.EndChangeCheck())
		{
			Undo.RecordObject(target, "Use gamma");
			prism.useGammaCorrection = useGamma;
		}
		
		if(prism.useGammaCorrection)
		{
			EditorGUI.BeginChangeCheck();
			float gamValue = EditorGUILayout.Slider(gammaValueContent, prism.gammaValue, 0.4f, 2.5f);
			if(EditorGUI.EndChangeCheck())
			{
				Undo.RecordObject(target, "Gamma");
				prism.gammaValue = gamValue;
			}
		}
		
		if (GUI.changed)
		{
			needsToSave = true;
			//this.OnEnable();
			//Debug.LogError("Gui changed");
			EditorUtility.SetDirty (target);

			if(prism.useLut == true && prism.useSecondLut == true && prism.secondaryTwoDLookupTex != null && prism.secondaryBasedOnTempTex != prism.secondaryTwoDLookupTex.name)
			{
				prism.Convert(prism.secondaryTwoDLookupTex, true);
			}

			if(prism.useLut == true && prism.twoDLookupTex != null && prism.basedOnTempTex != prism.twoDLookupTex.name)
			{
				prism.Convert(prism.twoDLookupTex);
			}	
		}
		
		serObj.ApplyModifiedProperties();
		
	}
	
	void ResetCurrentEffectsString(PrismEffects prism)
	{
		currentEffectsString = "";
		int numEffects = 0;
		
		if(prism.useBloom) { currentEffectsString += " Bloom,"; numEffects++; }// EditorGUILayout.LabelField("Bloom");

		if(prism.useFog) { currentEffectsString += " Fog,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");

		if(prism.useDof) { currentEffectsString += " Depth of field,"; numEffects++;}//EditorGUILayout.LabelField("Depth of field");

		if(prism.useAmbientObscurance) { currentEffectsString += " AO,"; numEffects++;}

		if(prism.useChromaticAberration) { currentEffectsString += " Chromatic aberration,"; numEffects++;}//EditorGUILayout.LabelField("Chromatic aberration");
		
		if(prism.useVignette) { currentEffectsString += " Vignette,"; numEffects++;}//EditorGUILayout.LabelField("Vignette");
		
		if(prism.useNoise) { currentEffectsString += " Filmic grain,"; numEffects++;}//EditorGUILayout.LabelField("Filmic grain");
		
		if(prism.useSharpen) { currentEffectsString += " Sharpen,"; numEffects++;}//EditorGUILayout.LabelField("Sharpen");
		
		if(prism.useNightVision) { currentEffectsString += " Night vision,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");
		
		if(prism.useTonemap) { currentEffectsString += " Tonemapping,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");

		if(prism.useExposure) { currentEffectsString += " Exposure Adaptation,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");

		if(prism.useGammaCorrection) { currentEffectsString += " Gamma Correction,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");
		
		if(prism.useLut) { currentEffectsString += " Color correction,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");

		if(prism.useRays) { currentEffectsString += " Godrays,"; numEffects++;}//EditorGUILayout.LabelField("Night vision");
	}
	
	[MenuItem("Assets/Create/PRISM Preset")]
	public static void CreatePrismPresetAsset()
	{
		PrismPreset asset = ScriptableObject.CreateInstance<PrismPreset>();
		
		string path = AssetDatabase.GetAssetPath(Selection.activeObject);
		if(path == "")
		{
			path = "Assets";
		} else if (Path.GetExtension(path) != "")
		{
			path = path.Replace(Path.GetFileName(AssetDatabase.GetAssetPath(Selection.activeObject)), "");
		}
		
		string assetPathAndName = AssetDatabase.GenerateUniqueAssetPath(path + "/New " + "PRISMPreset.Asset");
		
		AssetDatabase.CreateAsset(asset, assetPathAndName);
		AssetDatabase.SaveAssets();
		
		//EditorUtility.FocusProjectWindow();
		
		Selection.activeObject = asset;
		
	}
	
	void SaveValuesToPreset(PrismEffects prism, PrismPreset preset)
	{
		preset.useBloom = prism.useBloom;
		preset.bloomDownsample = prism.bloomDownsample;
		preset.bloomBlurPasses = prism.bloomBlurPasses;
		preset.bloomIntensity = prism.bloomIntensity;
		preset.bloomThreshold = prism.bloomThreshold;
		preset.useBloomStability = prism.useBloomStability;
		preset.bloomType = prism.bloomType;
		preset.useFullScreenBlur = prism.useFullScreenBlur;
		preset.bloomUseScreenBlend = prism.bloomUseScreenBlend;

		preset.useBloomLensdirt = prism.useLensDirt;
		preset.bloomLensdirtIntensity = prism.dirtIntensity;
		preset.bloomLensdirtTexture = prism.lensDirtTexture;

		preset.uiBlurGrabTextureFromPassNumber = prism.uiBlurGrabTextureFromPassNumber;
		preset.useUIBlur = prism.useUIBlur;

		preset.useDoF = prism.useDof;
		preset.dofRadius = prism.dofRadius;
		preset.dofSampleCount = prism.dofSampleAmount;
		preset.dofBokehFactor = prism.dofBokehFactor;
		preset.dofFocusPoint = prism.dofFocusPoint;
		preset.dofFocusDistance = prism.dofFocusDistance;
		preset.useNearBlur = prism.useNearDofBlur;
		preset.dofBlurSkybox = prism.dofBlurSkybox;
		preset.dofNearFocusDistance = prism.dofNearFocusDistance;
		preset.dofForceEnableMedian = prism.dofForceEnableMedian;

		preset.useChromaticAb = prism.useChromaticAberration;
		preset.aberrationType = prism.aberrationType;
		preset.chromIntensity = prism.chromaticIntensity;
		preset.chromStart = prism.chromaticDistanceOne;
		preset.chromEnd = prism.chromaticDistanceTwo;
		preset.useChromaticBlur = prism.useChromaticBlur;
		preset.chromaticBlurWidth = prism.chromaticBlurWidth;

		preset.useVignette = prism.useVignette;
		preset.vignetteIntensity = prism.vignetteStrength;
		preset.vignetteEnd = prism.vignetteEnd;
		preset.vignetteStart = prism.vignetteStart;
		preset.vignetteColor = prism.vignetteColor;

		preset.useNoise = prism.useNoise;
		preset.noiseIntensity = prism.noiseIntensity;

		preset.useTonemap = prism.useTonemap;
		preset.toneType = prism.tonemapType;
		preset.toneValues = prism.toneValues;
		preset.secondaryToneValues = prism.secondaryToneValues;

		preset.useExposure = prism.useExposure;
		preset.exposureMiddleGrey = prism.exposureMiddleGrey;
		preset.exposureLowerLimit = prism.exposureLowerLimit;
		preset.exposureUpperLimit = prism.exposureUpperLimit;
		preset.exposureSpeed = prism.exposureSpeed;
		
		preset.useGammaCorrection = prism.useGammaCorrection;
		preset.gammaValue = prism.gammaValue;

		preset.useLUT = prism.useLut;
		preset.lutIntensity = prism.lutLerpAmount;
		preset.lutPath = prism.basedOnTempTex;
		preset.twoDLookupTex = prism.twoDLookupTex;

		preset.useSecondLut = prism.useSecondLut;
		preset.secondaryLutLerpAmount = prism.secondaryLutLerpAmount;
		preset.secondaryLutPath = prism.secondaryBasedOnTempTex;
		preset.secondaryTwoDLookupTex = prism.secondaryTwoDLookupTex;
		
		preset.useNV = prism.useNightVision;
		preset.nvColor = prism.m_NVColor;
		preset.nvBleachColor = prism.m_TargetBleachColor;
		preset.nvLightingContrib = prism.m_baseLightingContribution;
		preset.nvLightSensitivity = prism.m_LightSensitivityMultiplier;

		preset.useFog = prism.useFog;
		preset.fogAffectSkybox = prism.fogAffectSkybox;
		preset.fogIntensity = prism.fogIntensity;
		preset.fogStartPoint = prism.fogStartPoint;
		preset.fogDistance = prism.fogDistance;
		preset.fogColor = prism.fogColor;
		preset.fogEndColor = prism.fogEndColor;
		preset.fogHeight = prism.fogHeight;

		preset.useAmbientObscurance = prism.useAmbientObscurance;
		preset.aoIntensity = prism.aoIntensity;
		preset.aoRadius = prism.aoRadius;
		preset.aoDownsample = prism.aoDownsample;
		preset.aoBlurIterations = prism.aoBlurIterations;
		preset.aoSampleCount = prism.aoSampleCount;
		preset.useAODistanceCutoff = prism.useAODistanceCutoff;
		preset.aoDistanceCutoffStart = prism.aoDistanceCutoffStart;
		preset.aoDistanceCutoffLength = prism.aoDistanceCutoffLength;
		preset.aoBias = prism.aoBias;
		preset.aoBlurType = prism.aoBlurType;
		preset.aoLightingContribution = prism.aoLightingContribution;

		preset.useRays = prism.useRays;
		preset.rayWeight = prism.rayWeight;
		preset.rayColor = prism.rayColor;
		preset.rayThreshold = prism.rayThreshold;
		
		needsToSave = false;
		
		Debug.Log("Saved values to preset: " + preset.name);

		EditorUtility.SetDirty(preset);
		EditorUtility.SetDirty(prism);
	}

	public static Texture2D FlipTexture(Texture2D original){
		Texture2D flipped = new Texture2D(original.width,original.height);
		
		int xN = original.width;
		int yN = original.height;
		
		
		for(int i=0;i<xN;i++){
			for(int j=0;j<yN;j++){
				flipped.SetPixel(i, yN-j-1, original.GetPixel(i,j));
			}
		}
		flipped.Apply(true);

		var bytes = flipped.EncodeToPNG();

		string path = AssetDatabase.GetAssetPath (original);
		System.IO.File.WriteAllBytes(path, bytes);
		
		AssetDatabase.Refresh();
		TextureImporter textureImporter = (TextureImporter)AssetImporter.GetAtPath(path);
		bool doImport = textureImporter.isReadable == false;
		if (textureImporter.mipmapEnabled == true) {
			doImport = true;
		}
		if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
			doImport = true;
		}
		
		if (doImport)
		{
			textureImporter.isReadable = true;
			textureImporter.mipmapEnabled = false;
			textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
			AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
		}

		return AssetDatabase.LoadAssetAtPath(path, typeof(Texture2D)) as Texture2D;

		//return flipped;
	}
	
	void LoadValuesFromPreset(PrismEffects prism, PrismPreset preset)
	{
		if(!preset)
		{
			return;
		}

		Debug.Log("Loading values from preset: " + preset.name);

		prism.SetPrismPreset(preset);

		if(preset.presetType == PrismPresetType.ColorCorrection || preset.presetType == PrismPresetType.Full)
		{
			if(preset.useLUT == true && preset.twoDLookupTex != null)
			{
				string path = AssetDatabase.GetAssetPath (preset.twoDLookupTex);
				TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
				bool doImport = textureImporter.isReadable == false;
				if (textureImporter.mipmapEnabled == true) {
					doImport = true;
				}
				if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
					doImport = true;
				}
				
				if (doImport)
				{
					textureImporter.isReadable = true;
					textureImporter.mipmapEnabled = false;
					textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
					AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
				}
			}
			
			if(preset.useLUT == true && prism.useSecondLut == true && preset.secondaryTwoDLookupTex != null)
			{
				string path = AssetDatabase.GetAssetPath (preset.secondaryTwoDLookupTex);
				TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
				bool doImport = textureImporter.isReadable == false;
				if (textureImporter.mipmapEnabled == true) {
					doImport = true;
				}
				if (textureImporter.textureFormat != TextureImporterFormat.AutomaticTruecolor) {
					doImport = true;
				}
				
				if (doImport)
				{
					textureImporter.isReadable = true;
					textureImporter.mipmapEnabled = false;
					textureImporter.textureFormat = TextureImporterFormat.AutomaticTruecolor;
					AssetDatabase.ImportAsset (path, ImportAssetOptions.ForceUpdate);
				}
			}
		}

		needsToSave = false;

		prism.enabled = false;

		EditorUtility.SetDirty(preset);
		EditorUtility.SetDirty(prism);

		prism.enabled = true;
	}
	
	
	
	
	
	
	
}
#endif